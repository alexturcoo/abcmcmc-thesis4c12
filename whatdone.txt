##This file will record things I have done for my thesis so far##
##I am learning c/c++ for my thesis to run an ABC-MCMC
##Might need to organize this file a little better to improve
#ifndef FOO_DOT_H    /* This is an "include guard" */
#define FOO_DOT_H readability

####################################################################
1. Created function which takes an integer value and generates a  
random amino acid sequence of that length (I used the string class
from c++ for this part) - string class allows for easy string
manipulation compared to using "an array of chars in c)                                         


std::string createSeq(int n){

    char aminoAcids[numAA] = { AMINO ACID SYMBOLS };

    std::string protein = "";
    for (int i = 0; i < n; i++){
        protein =  protein + aminoAcids[rand() % numAA];}

    std::cout << protein << "\n" << "\n" ;
    //printf("%s", protein.c_str());
    return protein;
}

####################################################################
2. The second function I began working on reads in the SRP40
protein which acts as the data that is already known, and it
creates a vector with characteristics like the length of the
sequence, the number of LCR's in the sequence, average entropy of
the LCRs - we must use segA to determine these characteristics.
- in C, we need to figure out how to call segA and record the value
  of the output and manipulate the value of the output as well (SEP
19 2022)
- I have created a symbolic link to the program segA and I will use
  that when I call segA from c/c++. (SEP 19 2022)
- Converted srp40 protein string into fasta file, fed that fasta file to segA, figured out how many low complexity regions are in the srp40 protien sequence (SEP 20 2022) 

int og_protein(){

    std::string srp40 = "MASKKIKVDEVPKLSVKEKEIEEKSSSSSSSSSSSSSSSSSSSSSSSSSGESSSSSSSSSSSSSSDSSDS\
SDSESSSSSSSSSSSSSSSSDSESSSESDSSSSGSSSSSSSSSDESSSESESEDETKKRARESDNEDAKE\
TKKAKTEPESSSSSESSSSGSSSSSESESGSESDSDSSSSSSSSSDSESDSESDSQSSSSSSSSDSSSDS\
DSSSSDSSSDSDSSSSSSSSSSDSDSDSDSSSDSDSSGSSDSSSSSDSSSDESTSSDSSDSDSDSDSGSS\
SELETKEATADESKAEETPASSNESTPSASSSSSANKLNIPAGTDEIKEGQRKHFSRVDRSKINFEAWEL\
TDNTYKGAAGTWGEKANEKLGRVRGKDFTKNKNKMKRGSYRGGSITLESGSYKFQD";

    //creating fasta file of protein string to use in segA
    std::ofstream MyFile("srp40.fasta"); //Create and open a fasta file
    MyFile << ">srp40_saccharomyces_cerevisiae\n" << srp40; //Write to the file
    MyFile.close(); //Close the file

    //getting the characteristics of the sequence
    int length = srp40.length();
    system("segA srp40.fasta 15 1.9 2.2 -l | grep '>' | wc -l >> numlcr.txt"); //Write the results of counting the LCRs to a txt file
    std::ifstream myreadfile("numlcr.txt"); //Declaring fstream variable and connecting it to a stream object by opening the file
    int num_lcr; //Declare int variable which holds the contents of the 'numlcr.txt' file
    myreadfile >> num_lcr; //Pipe file's content into stream
    //int avg_entropy_lcr =

    std::cout << srp40 << "\n" << "\n" << length << "\n" << "\n"<< num_lcr << "\n" ;
    return 0;
}

###################################################################################################
3. I created a repository on github so I could work both from home
and from the lab and push changes on both different devices (SEP 19
2022)
- always need to remember to push the changes from where I am
  working - once segA is involved, the code will only work when
running on the server

####################################################################################################
4. The third function I am working on is the function responsible for mutating the randomly generated protein sequence (SEP 21)
- Basically I need it to iterate through each amino acid in the generated sequence and choose a random exponential deviate from the
  exponential distribution (which models waiting times between events). Once I have generated a random exponential deviate for each amino
acid in the simulated sequence, I have to select the amino acid with the lowest value and select that amino acid to mutate into another
amino acid - I repeat this process of iterating through the sequence and assigning exponential deviates and mutating the lowest value for
a lot of generations (Brian suggested 1000 generations for 100 Amino acid sequence).
- Need to figure out a way to store the deviates in the same positions as amino acids so when we find the lowest number it matches the
  amino acid position

- SEPT 22 - Today I figured out that using a c++ vector is better
than using an array because arrays in c cant change size at runtime.
Vectors on the other hand can change size at runtime so we can add
values to it while iterating through the loop - today I just used
the rand() function because I could not get ran1 working for the
exponential deviates - I have basically intialized a vector,
iterated through the length of the simulated amino acid sequence and
produced a random number for that position in the amino acid - I
store these random values in a vector which is also 0 indexed and
matches the indices of the amino acid string.

std::string mutateSeq(std::string simulated_protein){

    std::vector<double> exp_deviates_vtr ; // Creating a vector to hold the values of the deviates

    // Traversing the string
    for (int i = 0; i < simulated_protein.length(); i++) {

        // Code to apply random exponential deviates to AA
        int deviate =  rand();
        exp_deviates_vtr.push_back(deviate);
    }

    // THIS IS JUST TO PRINT THE VECTOR
    for (int x = 0; x < exp_deviates_vtr.size(); i++) {
        std::cout << x << ' ';
    }
    

    return simulated_protein;
}

##################################################################################################################
5. SEPT 26 2022 - SO, mutation function got split up today into kind of 2 separate parts. Basically, we will not choose exponential deviates for
mutation, but rather choose a random poisson deviate with a mean equal to (mutation rate * # of sites) - choosing a random value from this
distribution could yield the same # of mutations as the mean, or more or less. Then we assign mutations randomly to the number of amino acids that we
get from this poisson distribution deviate. The second function will be created in order to handle amino acid expansion, and in this step we will use
exponential deviates - breaking the process up like this will save time. SIDE NOTE: We are using a poisson distribution because any kind of rare event
(like mutation rate) can be modeled by this. We will keep the function from above but modify it slightly - it will be the function that does the amino
acid expansion part
- I think I finished the function responsible for mutating the
sequence (choosing the number of mutations from a poisson
        distribution with a mean equal to the mutation rate * length
        of the sequence) - I just need to now get ran1 and the
poisson distribution in there because I am using rand() right now to
generate the sequences - CHECK ON THIS ASAP - the only thing I have
done is basically make a loop which uses the number of mutation
sites provided by the rand() function between 1-10 and changes that
- STILL WORKING ON FUNCTION TO LOOK BACKWARDS AND FORWARDS IN AMINO
ACID SEQUENCE TO CHECK FOR REPEATS AND ASSIGN DEVIATES (SEPT 26
        2022)

- SEPT 27 2022 - Updated code for the second mutation function.
Today I attempted to write the function which iterates through the
mutated protein sequence and assigns exponential deviates
(mutateSeqExp). Right now, the code looks for matching amino acids both upstream and
downstream the protein and the number of repeats is assessed per
amino acid. This means each amino acid is iterated through and the
same amino acids are looked for on either side of the amino
acid. The length of the repeat is then used in subsequent steps
like solving for beta = (mutation rate, length of repeat) and then
this beta value is used in the exponential distribution as the mean
- TRY TO FIND A WAY TO REMOVE BOTH COUNTERS AND JUST USE 1 COUNTER
IN mutateSeqExp - issue with counters getting incorrect values, fix
this.
- Today I also coded in the ability to scan for repeats (part 2 of the mutation function) - it is able to assign amino acids within repeats a longer length value than individual amino acids
which are not within repeats - this means we will be able to assign a random exponential deviate with a mean equal to the mutation rate times the length of the repeats. I am still having
issues with the random number generation and distribution functions, need to solve this ASAP (SEPT 27 2022)
- QUESTION (wrote in notebook as well), need to think about it - What does a larger mean, mean in terms of the exponential distribution? If I am saying to multiply the mutation rate by
the length of the repeats, this would mean a larger beta value going in as the mean of the exponential deviate, does a larger mean make a random number that will be small more likely?

- OCTOBER 3 2022 - Today I finally figured out how to implement Ran1 into my code. I have both the file that brian sent me "myRandomFunctions.c" which utilizes functions from the second edition of
  Numerical Recipes. Brian also gave me the third edition of the book which includes a newer random number generator called Ran - this one can be used as well to generate the deviates, I just need
to add the functions from numerical recipes thrid edition into the file called "functions.cpp" - I still need to add random deviate functions for normal distribution (to choose new mutation rates),
for exponential deviate function (for amino acid extension function), and poission deviates (to choose how many mutations to give my simulated protein per generation)
- So I used the functions from Numerical recipes third edition, I am trying to now test out using the poisson deviates and exponential deviates. The poisson deviates kept giving me 0 as an int
  because it was a float number but for a number of mutations should I be rounding the nearest whole number? Do I use floats or ints? I should not be getting such low numbers for my poisson deviate,
my poisson deviate is supposed to tell me how many mutations the sequence should undergo and right now I cant even get 1 mutation. FIGURE THIS OUT


//THIS FUNCTION WILL CHOOSE A RANDOM POISSON DEVIATE WITH A MEAN
//EQUAL TO (MUTATION RATE * # OF SITES) - WHATEVER THE VALUE OF THE
//RANDOM DEVIATE, CHOOSE THAT MANY MUTATIONS IN THE SEQUENCE AT
//RANDOM

std::string mutateSeqAA(std::string simulated_protein){

    float mutation_rate = 0.14 ; // just setting mutation rate here now
    float avg_mutations = mutation_rate * simulated_protein.length() ;
    int poisson_deviate_num_mutations = (rand() % 10) + 1 ; //Choose random poisson deviate with mean = avg_mutations
    
    //This for loop will give 5 random sites mutations
    for (int i = 0; i < poisson_deviate_num_mutations; i++) {

        char aminoAcids[numAA] = { 'G', 'A', 'L', 'M', 'F', 'W', 'K', 'Q', 'E', 'S', 'P', 'V', 
                                   'I', 'C', 'Y', 'H', 'R', 'N', 'D', 'T' };
        
        char random_AA = aminoAcids[rand() % numAA]; // sets up the random amino acid, same used in first function to createSeq
        int random_site = rand() % simulated_protein.length(); // Gives random number in range (0 - length of protein sequence)
        simulated_protein[random_site] = random_AA; // indexes the simulated protein at a random spot and replaces the existing AA with a new random one
    }

    //std::cout << avg_mutations << "\n" << "\n" << simulated_protein << "\n" ;
    return simulated_protein ;
}

////////////////////////////////////////////////////////////////////////
// THIS FUNCTION WILL MUTATE THE SIMULATED PROTEIN SEQUENCE
// BY CHOOSING A RANDOM EXPONENTIAL DEVIATE (WITH MEAN = MUTATION RATE)
// FOR EACH AMINO ACID IN THE SEQUENCE AND SUBSEQUENTLY SELECTING
// THE AMINO ACID WITH THE LOWEST NUMBER (QUICKEST TO MUTATE) AND
// MUTATING IT RANDOMLY, THIS IS DONE SUCCESSIVELY TO PRODUCE A 
// PROTEIN AND CREATE A VECTOR OF VALUES SIMILAR TO ABOVE (SEP 21)     
// SEP 26 - PROCESS CHANGE, THIS FUNCTION WILL BE USED FOR AMINO ACID EXPANSION

std::string mutateSeqExp(std::string simulated_protein){

    std::vector<double> exp_deviates_vtr ; // Creating a vector to hold the values of the deviates

    // Traversing the string
    for (int i = 1; i < simulated_protein.length() + 1; i++) {

        int forward_counter = 1 ;
        int reverse_counter = 1 ;

        //Code to scan back and forth to find repeats
        if (simulated_protein[i] != simulated_protein[i+1] && simulated_protein[i] != simulated_protein[i-1]) {
            float mutation_rate = 0.14 ; //mutation rate == alpha
            float beta = mutation_rate*1 ; // 1 will always be used here because the length if no repeats is 1
            int deviate = rand() ;//here we choose exp_deviate(mean of beta)
            exp_deviates_vtr.push_back(deviate) ; //Here we are storing the exponential deviates
        } else {
            int x = 1 ;
            int y = 1 ;

            while (simulated_protein[i] == simulated_protein[i + x]) {
                forward_counter += 1 ;
                x++;
            } 

            while (simulated_protein[i] == simulated_protein[i - y]) {
                reverse_counter += 1 ;
                y++;
            }

            float mutation_rate = 0.14 ;
            float beta = mutation_rate*(forward_counter + reverse_counter);
            int deviate = rand();
            exp_deviates_vtr.push_back(deviate);
        }
    }
    // THIS IS JUST TO PRINT THE VECTOR
    for (int x = 0; x < exp_deviates_vtr.size(); x++) {
        std::cout << exp_deviates_vtr[x] << ' ';
    }
    
    std::cout << simulated_protein << "\n" << "\n" ;
    return simulated_protein;
}

November 2 2022 - Things have been busy recently, but today I separated all
of my functions that were in one file, into their own respective file. I will also
create a Makefile to compile each of the functions for initial testing.
- createseq.cpp works on its own and produces a random sequence of amino acids - this is using the c++ rand, I think its okay in this case
- observed_protein.cpp function is still in the works but it works on its own and will be the vector of summary statistics for the observed data (srp40 right now)
- mutations.cpp contains both functions which will be used in the mutation step - I have got the first part working where a random poisson deviate is selected and
  that number is the number of amino acids to mutate - this step works, now I have to get the second function with the exponential deviates to work. (Updated code
on github) - exponential deviates part is working, just having difficulty generating random exponential deviates on each iteration of the loop. I get the same
value of exponential deviate for individual residues and the same value of exponential deviate for residues part of a repeat, run the code for mutations.cpp to
check it out - get some help with this.

November 3 2022 - Still trying to get different random deviates in mutations.cpp program. When I run it I am getting the same deviates for individual residues and the
same deviates for repeats part of a bunch of repeats. It is very weird. I am talking to Brian about the issue today in our meeting.
- After meeting with Brian, he basically figured that using time was not working as a way to get different seeds on each iteration of the loop, we instead used
  myran.int64() as the argument for the seeds of the exponential deviates and now we have different deviates for each amino acid!!!1 SO HYPE LETS GO

November 7 2022 - today I am working on adding to the mutations.cpp code. What I need to do is first select the lowest exponential deviate which represents the amino acid
that is going to change the quickest. Then, at that site we either insert or remove a repeat. To do this we will have Ran select a random number between 0 and 1, and
if the number is less than 0.5, we do a deletion of the site and if the random number is larger than 0.5, we insert another of the same amino acid.
- added a function called getIndex which grabs the index of the lowest number in the vector by supplying it with the vector and the value and it will find the
  index. 
- Next I am adding code to generate a random number between 0 and 1 and if its less than 0.5, deletion and if its larger than 0.5 insertion - is this where indel
  rate comes up?
QUESTION
- need to figure out where to set indel rate... I have already set a mutation rate but I do not know where to add the indel rate... is it set at the part where we
generate a random number and see if its less than or greater than 0.5? Talk to Brian - okay the answer for this is that we run once through with the mutation rate,
and once through with the indel rate... lets see how that works lol

November 8 2022 - Today before my c++ test, I wrote some code to select the lowest deviate and either insert or delete an amino acid based on a random number
generated between 0 and 1. - the code ended up working and I am so so happy. At this point, my mutations.cpp program will first take an amino acid sequence,
generate a single random possion deviate from a poisson distribution with mean = protein.length*mutation.rate. This gives us the number of amino acids to mutate and
at random, that number of amino acids are mutated. The program then has a function which scans for repeats and inserts or deletes a repeat where the lowest exponential deviate was
assigned.
SAMPLE OUTPUT FROM MUTATIONS.CPP
before mutateseqAA:	MKNHCHKISAKHHHHAM
after mutateSeqAA:	MKLHCVSISFKAHHHAE

after mutateSeqEXP:	MKLHCVSSISFKAHHHAE


November 9 2022 - Today I spent the day figuring out how to call seg and find the average entropy of the observed protein sequence srp40. The way in which I did this was using
a system call to segA with the chosen parameters, then using awk, and grep I manipulated the output to only get the complexity values and then I added these values up and
divided by the number of values to get the average entropy of the LCRs. I will drop some cool commands that I used here, just taking a break.
 
 system("segA srp40.fasta 15 1.9 2.2 -l | grep 'complexity' | awk '{print $2}' | egrep -o '([0.0-9.0]+)' | awk '{sum += $1} END {print mean=sum/NR}' >> avg_entropy_lcrs.txt");

This command essentially grabs the output of segA and outputs the mean avg entropy of the LCRs. Basically it finds where the output has complexity
in it and from here we grab all the numbers, add them up, nad divide them by how many numbers there were to get an average entropy. Cool command

November 10 2022 - Today is my meeting with Brian. I have been doing alot of work on finding out which distance measure to use to find the
difference in the vectors of summary statistics. This paper is a good one for showing the complete algorithm of an ABC with a weighted distance
measure. https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1449703/#eqn1 - First we need to find an appropriate way to store the vectors of summary
statistics in order to successfully calculate the euclidean distance.
- After talking to Brian, he confirmed that I should use euclidean distance to calculate the distance between the vector of both summary statistics. 
I still need to ask him about normalizing the vector because some values are super large
- Brian also suggested I follow the Hamilton Paper and attempt to calculate weighted values the same way they did in this paper. What this entails is running a linear regression
and then pulling the R^2 value and using that to calculate the weight. This calculation is done after simulating over numerous generations. Also the paper first did this in a way that
did not use weights and then they used weights to show how it improved it, maybe I could do the same but GET IT WORKING WITHOUT WEIGHTS FIRST.
- I took a function from online which calculates the euclidean distance between two vectors which works. In order to better understand this I am also going to try to get this calculation 
working with some of my own code!! - HAHAHHA I DID IT LETS GOO AMD ITS SO MUCH EASIER TO UNDERSTAND THAN THE OTHER CODE I TOOK FROM THE INTERNET
- Now that I have the euclidean distance calculation working I need to go and put the values I got in observed_protein.cpp and store them in vectors so my distance function will work on them.
- successfully stored the values of the observed protein in a std::vector<double> which is awesome because now once I get the simulated protein std::vector<double of summary statistics my function
uses vectors of the double type so we will be able to calculate distance. 
- The next thing I am going to do is write a separate function to store the summary statistics of the simulated protein. I made a new file which basically returns the same vector as the observed
protein function. I now have a way to store the summary statistics for both observed and simulated data, AND a way to calculate the euclidean distance between those values!!
- The next thing I started doing was assembling the abcmcmc.cpp file which is the main file that will connect all of the functions I created in different files. Basically I linked all the files to
abcmcmc.cpp and now I am using the functions I made in that file, where I will write the algorithm now for an abc mcmc - we also need to think about the linear regression aspects to get the weights
that we can use for the distances because right now we have no weights when calculating the distance. We still need to do some tests and try to calulate the distance for  some vectors I produce with my
code! For today, I am stopping, uploading all this to github. ALSO A LITTLE SIDE NOTE FOR YOURSELF XANDER - GOOD NOTES ARE ON YOUR IPAD
